domain: swe-lite
topic: python
train_or_test: TEST
repo: ''
task_name: django__django-12453
revision: b330b918e979ea39a21d47b61172d112caf432c3
dockerfile: ./Dockerfile
integrations_yaml: ../../extra/_integrations.yaml
variables_yaml: ./_variables.yaml
verification:
    run_python: ../../extra/verification.py
    run_python_params:
    - django__django-12453
    - princeton-nlp/SWE-bench_Lite
    - test
task:
-   role: user
    content: "\n            You are solving a Github issue in the repository .\n            You must make the changes to solve,\
        \ close, or address the issue, directly in the code.\n            `TransactionTestCase.serialized_rollback` fails\
        \ to restore objects due to ordering constraints\nDescription\n\t\nI hit this problem in a fairly complex projet and\
        \ haven't had the time to write a minimal reproduction case. I think it can be understood just by inspecting the code\
        \ so I'm going to describe it while I have it in mind.\nSetting serialized_rollback = True on a TransactionTestCase\
        \ triggers â€‹rollback emulation. In practice, for each database:\nBaseDatabaseCreation.create_test_db calls connection._test_serialized_contents\
        \ = connection.creation.serialize_db_to_string()\nTransactionTestCase._fixture_setup calls connection.creation.deserialize_db_from_string(connection._test_serialized_contents)\n\
        (The actual code isn't written that way; it's equivalent but the symmetry is less visible.)\nserialize_db_to_string\
        \ orders models with serializers.sort_dependencies and serializes them. The sorting algorithm only deals with natural\
        \ keys. It doesn't do anything to order models referenced by foreign keys before models containing said foreign keys.\
        \ That wouldn't be possible in general because circular foreign keys are allowed.\ndeserialize_db_from_string deserializes\
        \ and saves models without wrapping in a transaction. This can result in integrity errors if an instance containing\
        \ a foreign key is saved before the instance it references. I'm suggesting to fix it as follows:\ndiff --git a/django/db/backends/base/creation.py\
        \ b/django/db/backends/base/creation.py\nindex bca8376..7bed2be 100644\n--- a/django/db/backends/base/creation.py\n\
        +++ b/django/db/backends/base/creation.py\n@@ -4,7 +4,7 @@ import time\n from django.apps import apps\n from django.conf\
        \ import settings\n from django.core import serializers\n-from django.db import router\n+from django.db import router,\
        \ transaction\n from django.utils.six import StringIO\n from django.utils.six.moves import input\n \n@@ -128,8 +128,9\
        \ @@ class BaseDatabaseCreation(object):\n\t\t the serialize_db_to_string method.\n\t\t \"\"\"\n\t\t data = StringIO(data)\n\
        -\t\tfor obj in serializers.deserialize(\"json\", data, using=self.connection.alias):\n-\t\t\tobj.save()\n+\t\twith\
        \ transaction.atomic(using=self.connection.alias):\n+\t\t\tfor obj in serializers.deserialize(\"json\", data, using=self.connection.alias):\n\
        +\t\t\t\tobj.save()\n \n\t def _get_database_display_str(self, verbosity, database_name):\n\t\t \"\"\"\nNote that\
        \ loaddata doesn't have this problem because it wraps everything in a transaction:\n\tdef handle(self, *fixture_labels,\
        \ **options):\n\t\t# ...\n\t\twith transaction.atomic(using=self.using):\n\t\t\tself.loaddata(fixture_labels)\n\t\t\
        # ...\nThis suggest that the transaction was just forgotten in the implementation of deserialize_db_from_string.\n\
        It should be possible to write a deterministic test for this bug because the order in which serialize_db_to_string\
        \ serializes models depends on the app registry, and the app registry uses OrderedDict to store apps and models in\
        \ a deterministic order.\n"
