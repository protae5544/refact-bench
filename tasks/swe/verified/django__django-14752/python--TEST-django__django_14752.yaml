domain: swe-verified
topic: python
train_or_test: TEST
repo: ''
task_name: django__django-14752
revision: b64db05b9cedd96905d637a2d824cbbf428e40e7
dockerfile: ./Dockerfile
integrations_yaml: ../../extra/_integrations.yaml
variables_yaml: ./_variables.yaml
verification:
    run_python: ../../extra/verification.py
    run_python_params:
    - django__django-14752
    - princeton-nlp/SWE-bench_Verified
    - test
task:
-   role: user
    content: "\n            You are solving a Github issue in the repository .\n            You must make the changes to solve,\
        \ close, or address the issue, directly in the code.\n            Refactor AutocompleteJsonView to support extra fields\
        \ in autocomplete response\nDescription\n\t \n\t\t(last modified by mrts)\n\t \nAdding data attributes to items in\
        \ ordinary non-autocomplete foreign key fields that use forms.widgets.Select-based widgets is relatively easy. This\
        \ enables powerful and dynamic admin site customizations where fields from related models are updated immediately\
        \ when users change the selected item.\nHowever, adding new attributes to autocomplete field results currently requires\
        \ extending contrib.admin.views.autocomplete.AutocompleteJsonView and fully overriding the AutocompleteJsonView.get()\
        \ method. Here's an example:\nclass MyModelAdmin(admin.ModelAdmin):\n\tdef get_urls(self):\n\t\treturn [\n\t\t\tpath('autocomplete/',\
        \ CustomAutocompleteJsonView.as_view(admin_site=self.admin_site))\n\t\t\tif url.pattern.match('autocomplete/')\n\t\
        \t\telse url for url in super().get_urls()\n\t\t]\nclass CustomAutocompleteJsonView(AutocompleteJsonView):\n\tdef\
        \ get(self, request, *args, **kwargs):\n\t\tself.term, self.model_admin, self.source_field, to_field_name = self.process_request(request)\n\
        \t\tif not self.has_perm(request):\n\t\t\traise PermissionDenied\n\t\tself.object_list = self.get_queryset()\n\t\t\
        context = self.get_context_data()\n\t\treturn JsonResponse({\n\t\t\t'results': [\n\t\t\t\t{'id': str(getattr(obj,\
        \ to_field_name)), 'text': str(obj), 'notes': obj.notes} # <-- customization here\n\t\t\t\tfor obj in context['object_list']\n\
        \t\t\t],\n\t\t\t'pagination': {'more': context['page_obj'].has_next()},\n\t\t})\nThe problem with this is that as\
        \ AutocompleteJsonView.get() keeps evolving, there's quite a lot of maintenance overhead required to catch up.\nThe\
        \ solutions is simple, side-effect- and risk-free: adding a result customization extension point to get() by moving\
        \ the lines that construct the results inside JsonResponse constructor to a separate method. So instead of\n\t\treturn\
        \ JsonResponse({\n\t\t\t'results': [\n\t\t\t\t{'id': str(getattr(obj, to_field_name)), 'text': str(obj)}\n\t\t\t\t\
        for obj in context['object_list']\n\t\t\t],\n\t\t\t'pagination': {'more': context['page_obj'].has_next()},\n\t\t})\n\
        there would be\n\t\treturn JsonResponse({\n\t\t\t'results': [\n\t\t\t\tself.serialize_result(obj, to_field_name) for\
        \ obj in context['object_list']\n\t\t\t],\n\t\t\t'pagination': {'more': context['page_obj'].has_next()},\n\t\t})\n\
        where serialize_result() contains the original object to dictionary conversion code that would be now easy to override:\n\
        def serialize_result(self, obj, to_field_name):\n\treturn {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}\n\
        The example CustomAutocompleteJsonView from above would now become succinct and maintainable:\nclass CustomAutocompleteJsonView(AutocompleteJsonView):\n\
        \tdef serialize_result(self, obj, to_field_name):\n\t\treturn super.serialize_result(obj, to_field_name) | {'notes':\
        \ obj.notes}\nWhat do you think, is this acceptable? I'm more than happy to provide the patch.\n"
